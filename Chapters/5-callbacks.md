## CallbacksMany libraries implement functionalities that require to call to our code. This is done to have more flexible libraries, to allow us to extend them or to provide special code for our use case.A nice and simple example of this is the `qsort` function in the standard C library.This function sorts an array of elements using the QuickSort algorithm.This implementation sort the elements in place, so it modifies the passed array.To have a flexible function that can work on an array of any data type, the function requires that we pass the size of each of the elements in the array and also the size of the whole array.So an initial definition of the `qsort` function could be something like:```	void qsort(void *base, size_t sizeOfArray, size_t sizeOfEachElement)```In this function we are passing a pointer to an array\(`base`\), the size of the array \(`sizeOfArray`\) and the size of each of the elements in the array \(`sizeOfEachElement`\).As an example we can use `qsort` to sort an array of 10 `Animal` structs. ```struct Animal{
	char* name;
	int age;
}

struct Animal myAnimals[10];```However, as this struct has an arbitrary format it is impossible to write a generic function to sort this array.There is no way of comparing the elements. So we need to give it a function that is able to compare each of the elements.This function is part of our code and will be called by the `qsort` function to decide how to sort the elements.This function should handle to pointers to the elements in the array and then it will return an integer to say the result of the comparison. It should return a negative number if the first element is smaller \(it goes first in the sorted collection\), 0 if they are equal, and a positive number if the element is bigger \(it goes after in the sorted collection\).An example of this given function comparing animals by age:```int compareAnimals(struct Animal* oneAnimal, struct Animal* anotherAnimal){
	if(oneAnimal->age == anotherAnimal->age)
		return 0;
	
	if(oneAnimal->age < anotherAnimal->age)
		return -1;

	return 1;
}```As you can see, this function is part of our code, it is not part of the library.We will call this functions callbacks, as this functions are called back from the library to our code. Of course, we will see how to implement an equivalent function in Pharo. To use callbacks function we need to be able to pass a pointer to the function or to store this pointer in a given structure.In the case of our example, the `qsort` function, the callback is passed as a parameter of the function, so the real definition of the function is the following:```void qsort(void *base, size_t sizeOfArray, size_t sizeOfEachElement,
                  int (*comparisonCallback)(const void *, const void *));```As you can see, the `comparisonCallback` parameter is defined as it is a C function, with the addition of the `*` operator to establish it is a pointer to the function.Existing libraries A callback is, as its name says, when an external function calls back Pharo to inform/require/do something. The typical example done with the C function qsort \(quick sort\), which calls a comparator function to determine element position. This example can be found on `FFICallback class >> exampleCqsort`.To pass a callback to a C function, we need to declate it providing the expected signature and the execution block: ```callback := FFICallback
	signature:  #(int (const void *arg1, const void *arg2))
	block: [ :arg1 :arg2 | ((arg1 doubleAt: 1) - (arg2 doubleAt: 1)) sign ].```This will declare an anonymous function that receives as parameter two void pointers \(arg1, arg2\) and answers an int. The function that will receive this callback as argument needs to be modified to declare the correct type \(as is shown also in FFIExternalArray section\): ```FFICallback class >> primQsort: array with: count with: size with: compare [
	self
		ffiCall: #(void qsort (FFIExternalArray array, size_t count, size_t size, FFICallback compare)) 
		module: LibC
]```then you will just use as any other regular parameter.Some remarks: - You need to be really careful on how you keep your callbacks: since you do not know when it will be executed, there is always the possibility for the VM to garbage collect them while in execution. In that case your image will crash. The best solution here is to keep a strong reference of the callback while you know it will be alive.- Callbacks are tricky! Do not over-use them, the VM is not prepared to execute callbacks inside callbacks ot other special behaviours \(it may be in the future, but for now best is to keep callbacks as small as possible\).