!! Foreign Function Interface and Call\-Outs

This chapter presents a fair introduction to uFFI by introducing function call\-outs i.e. calling out to external functions.
We start by defining a Pharo uFFI binding to a C function.
This example will guide us through how uFFI manages to find and load libraries, and how it looks up functions therein.
Finally, when executing the binding, the returned value should be transformed into a Pharo object.
Such transformation is called marshalling.

In the second part of this chapter, we refactor the initial example to extract the library into an ==FFILibrary== object.
A library object can cope with platform-independent library lookup and smarter library searches.

!!! Calling a simple external function

To illustrate the purpose and usage of uFFI, we will start with an example.
Suppose we want to know the amount of time the image has been running by calling the underlying OS function
named ==clock==. This function is part of the standard C library (==libc==). Its declaration in C is\:

[[[
clock_t clock( void );
]]]

For the sake of simplicity, let\'s treat ==clock()==\'s return type as an unsigned, ==uint==, instead of ==clock\_t==.
(We will discuss types, conversions, and typedefs in subsequent chapters.)
This results in the following C function declaration\:

[[[
uint clock( void );
]]]

To call ==clock()== from Pharo using uFFI, we need to define a binding between a Pharo method and the ==clock()== function.
uFFI bindings are classes and methods that provide an object\-oriented means of accessing C libraries, implementing all the glue required to join the Pharo world and the C world.

To write our first binding, let\'s start by defining a new class, ==FFITutorial==.
This class will act as a module and encapsulate, not only the functions we want to call, but also any state we would like to persist.
To access the ==clock()== function, we then define a method in our ==FFITutorial== class using the ==ffiCall\:library\:== message to specify the declaration of the C function and indicate where it is defined. We will technically refer to this binding as a ''call\-out'', since it ''calls'' a function in the ''outside'' world (the C world).

If our Pharo code is hosted on a Linux system, we define this class and (class\-side) method like so\:

[[[language=smalltalk
Object subclass: #FFITutorial
	instanceVariableNames: ''
	classVariableNames: ''
	package: 'FFITutorial'

FFITutorial class >> ticksSinceStart [
  ^ self ffiCall: #( uint clock() ) library: 'libc.so.6'
]
]]]

where we have simply copied the C declaration into a Pharo Array literal, then added ==\'libc.so.6\'== as a reference to the current version of its C shared library on our Linux host system.  (We can find out which version we have by entering ==ls \-1 /lib/\*/libc.so\*== in a Linux terminal window.)

To define the same binding for other host platforms, we need to replace the ==\'libc.so.6\'== string by e.g., ==\'libc.dylib\'== if we\'re running on MacOS, or ==\'msvcrt.dll\'== if we use Windows. The equivalent definitions for MacOS and Windows are then\:

[[[language=smalltalk
FFITutorial class >> ticksSinceStart [
  ^ self ffiCall: #( uint clock() ) library: 'libc.dylib'
]
]]]

and

[[[language=smalltalk
FFITutorial class >> ticksSinceStart [
  ^ self ffiCall: #( uint clock() ) library: 'msvcrt.dll'
]
]]]

Finally, we can use our freshly\-created binding in a Pharo playground by inspecting or printing the following expression\:

[[[language=smalltalk
FFITutorial ticksSinceStart
]]]

If everything works as expected, this expression will return the number of native clock ticks since our Pharo process was launched.

!!! Analyzing the FFI Call\-Out
@OriginalTicksSinceStartBinding

The simple example we ran in the previous section illustrates several important uFFI concepts.
For starters, let\'s look at the binding definition again\:

[[[language=smalltalk
FFITutorial class >> ticksSinceStart [
	^ self ffiCall: #( uint clock() ) library: 'libc.so.6'
]
]]]

This call\-out binding, a Pharo method, is called ==ticksSinceStart== and happens to be named differently than the C function we are calling.
Indeed, uFFI does not impose any restrictions on naming your external function wrapper methods.  This can come in handy for decoupling your methods from underlying C\-level implementation details.

We invoke the C function using the Pharo method ==ffiCall\:library\:==, which is defined by uFFI.  We provide the message the arguments it needs usually by just copying and pasting the target C function declaration inside a Pharo Array literal, then referencing the name of the library in which it\'s defined (which in general will depend on our host platform).

uFFI interprets the declaration and performs all the necessary work needed to make the call\-out and return the result.  In general, uFFI goes through the following steps:
1. Search for the specified library in the host system.
1. On finding it, load the C library into memory.
1. Index the specified function within the library.
1. Transform and push Pharo arguments (if any) onto the stack.
1. Perform the call to the C function.
1. And finally, transform the return value into a Pharo object.

To form the first argument in our example, we render our C declaration for ==clock()== in Pharo as a literal string array, like so\:

[[[
#( uint clock() )
]]]

The first element of our array is ==uint==, which is the function return ''type''.  This is followed by the function name, ==clock==.  Following the function name, we embed another Pharo ==Array== to list the formal arguments the C function expects, in order. In this case, ==clock()== takes no arguments, so we must provide an empty ==Array==.

Another way to think of the declaration argument is this\: If we look past the outer ==\#( )== wrapper, what we see inside is our C function prototype, appearing very similar to normal C syntax.  This convenience is possible due to the coincidental nature of Smalltalk syntax\: our use of strings and array notation in Pharo nicely mirrors how we write a C function declaration.  uFFI was intentionally designed to take advantage of this, so that in most cases we can simply copy\-paste a C function declaration taken from a header file or documentation, wrap it in ==\#( )==, and it\'s ready for use\!

Our ==ffiCall\:library\:== message also needs a second argument (==\'libc.so.6\'== in our Linux example), which is the name of the library on our host that contains the function.  In many cases we do not need to provide a full path to the file in our host system.  However, it should already be apparent that our bindings can be platform-dependent if the library we need is also platform dependent.  We will explore how to define bindings in a platform\-independent way in a following section.

!!! Notes on Value Marshalling

To fully understand the previous example, we still need to explain how the C ==uint== return value (a non\-object\; a cluster of ''bytes'' popped off the stack) gets transformed into a Pharo ==SmallInteger== ''object''.  Remember, C does not understand objects and does not do us the favor of returning values as attributes encapsulated within an object.  We must somehow create an appropriate type of Pharo object, then initialize it with the C return value.  Our code then receives this Pharo object.

This process of converting values between different internal representations is called ''marshalling'', and in most cases is managed automatically in Pharo by uFFI.  For example, uFFI internally maps the following standard C values to Smalltalk objects\:
- Types ==int==, ==uint==, ==long==, ==ulong== are marshalled as Pharo integers (small or long integers, depending on the platform architecture).
- Types ==float== and ==double== are marshalled into Pharo floats.

Correct marshalling (and ''demarshalling'') of values is therefore crucial for correct behavior of the bindings, particularly because the C language is so closely tied to underlying machine architecture. And yet, C values are merely \"naked\" bits and bytes in registers and memory\; they have no inherent context or meaning.  Consequently, they can be interpreted in many different contexts, including by the Pharo run\-time engine.  The correct interpretation, involving such issues as byte ordering, type size, alignment requirements, string length/termination, etc. must be knowable, known, and properly handled.  An object can tell you what it is, but a string of bits is just a string of bits...

As an example, consider the C integer value 0x00000000 (four contiguous \'0x00\' bytes).  This can be interpreted as the small integer zero, as the ''false'' object, or as a null pointer \-\- all depending on the marshalling rule selected for the inferred type.  This means that the developer coding the binding method needs to ''carefully'' and ''correctly'' describe the types of argument bindings so uFFI will then correctly interpret and transform those values.  This is programming at the ABI level (binary representations), so precision counts\!  You are working side\-by\-side with the compiler, and inattention to detail can lead to crashes (or strange behavior that can be difficult to diagnose).

In the following chapters we will explore the marshalling rules in more detail and see how they apply not only for return values but also for arguments.
Moreover, we will learn how to define our own user\-defined data types and type mappings, allowing us to customize and fine\-tune the marshalling rules to fit our particular needs.

!!! Libraries

We saw earlier that a call\-out binding requires us to specify the library that uFFI should use to locate and load the desired function.  In our previous example, we indicated to Pharo that the ==clock()== function was inside the standard C library, namely, the file ==libc.so.6==.  However, this form of the library exists in Linux systems, but not in Windows.

So we could say that this solution is not portable enough. After all, one of the hallmark qualities of Smalltalk is supposed to be platform-independence.  But if we want to load and run ''this'' code on a different host platform, we are faced with changing the library name to match the name on our new host system.  Worse, the libraries we need will all too often not have the same name, nor be located in the same place on all platforms. Not only that, we would need to be sure we catch every instance of these dependencies when we perform this \"migration\". Ugh\!

One way to overcome this issue would be to define a set of bindings, one per platform, and decide which one to call based on which platform we detect at run\-time, as follows\:

[[[language=smalltalk
FFITutorial class >> ticksSinceStart [
  self platform isUnix
    ifTrue: [ ^ self ticksSinceStartUnix ].
  self platform isOSX
    ifTrue: [ ^ self ticksSinceStartOSX ].
  self platform isWindows
    ifTrue: [ ^ self ticksSinceStartWindows ].
  self error: 'Non-supported platform'
]

FFITutorial class >> ticksSinceStartUnix [
  ^ self ffiCall: #( uint clock() ) library: 'libc.so.6'
]

FFITutorial class >> ticksSinceStartOSX [
  ^ self ffiCall: #( uint clock() ) library: 'libc.dylib'
]

FFITutorial class >> ticksSinceStartWindows [
  ^ self ffiCall: #( uint clock() ) library: 'msvcrt.dll'
]
]]]

But this solution means our binding code (which is essentially the same in all cases) gets repeated three times, and any changes to the binding design will require changing all three binding methods. This may seem okay for our simple ==clock()== binding, but as usage gets more complex, this code duplication will become a problem...

uFFI solves this problem by allowing us to use ''library objects'' instead of plain strings like we did earlier.  A library object represents a library as an instance of ==FFILibrary==, abstracting away any platform dependencies.  This library class defines methods ==macModuleName==, ==unixModuleName==, and ==win32ModuleName==\; uFFI internally selects the correct library name at run\-time (after sensing the host platform). Bonus\: This selection is a ''process'', not a literal (i.e. a string), so it can now include behavior, such as the ability to dynamically search through different directories on your host system to locate the correct version of a library, as we will see shortly.

So for our example, we can now define such a library, ==MyLibC==, as follows (being careful to note that the methods are ''instance side'' overrides)\:

[[[language=smalltalk
FFILibrary subclass: #MyLibC
	instanceVariableNames: ''
	classVariableNames: ''
	package: 'UnifiedFFI-Libraries'

MyLibC >> unixModuleName [
	^ 'libc.so.6'
]

MyLibC >> macModuleName [
	^ 'libc.dylib'
]

MyLibC >> win32ModuleName [
	"While this is not a proper 'libc', MSVCRT has the functions we need here."
	^ 'msvcrt.dll'
]
]]]

To use this improved technique, we modify our original binding method (in *@OriginalTicksSinceStartBinding*) to substitute our library ''object'' (as a class) in place of the library name ''string''\:

[[[language=smalltalk
FFITutorial class >> ticksSinceStart [
	^ self ffiCall: #( uint clock() ) library: MyLibC
]
]]]

''This'' version will run on all three platform types, ''and'' do so with each datum specified only once.

!!! Library Searching

The ==macModuleName==, ==unixModuleName==, and ==win32ModuleName== methods allow us, as developers, to employ different strategies to search for libraries and functions, depending on our host platform. If these methods return a relative path, library searching starts in common/default library directories on the system, or adjacent to the virtual machine executable. If they return an absolute path, only the specified path will be searched - ''not'' the default system locations. In either case, if the library is not found or cannot be loaded, an exception is raised.

For example, an alternative override for ==unixModuleName== can limit the search for ==libc== to only the host's ==/usr/lib/== directory\:

[[[language=smalltalk
MyLibC >> unixModuleName [
	^ '/usr/bin/libc.so.6'
]
]]]

Moreover, we are not constrained to simply return a string containing a path. The use of a method allows us to define and follow complex search rules, potentially locating needed libraries dynamically.

To take a real\-world example, let\'s consider where the Cairo graphics library installs its resources on Unix\-type systems. Although they are generally compatible, different \'\*nix\' distros have evolved in ways that occasionally led to divergence in their file system structure, the placement of operating system files, and where they prefer to install user-added packages.  This is especially true (for historical reasons) where structure was added to avoid mixing 32\-bit and 64\-bit libraries.  (Unix pre\-dates the 8\-bit micro\-computer age.  It may be older than you are\!)

In the example below, the Cairo library search method for Linux checks for the existence of the library in each of ==/usr/lib/i386\-linux\-gnu==, ==/usr/lib32==, and ==/usr/lib==, and if found, returns the absolute path to that file\:

[[[language=smalltalk
CairoLibrary >> unixModuleName [
		"On different flavors of Linux, the path to the library may differ, depending on the distro and whether the system is 32- or 64-bit."

		#(
			'/usr/lib/i386-linux-gnu/libcairo.so.2'
			'/usr/lib32/libcairo.so.2'
			'/usr/lib/libcairo.so.2' )
		do: [ :path |
			path asFileReference exists ifTrue: [ ^ path ] ].

		self error: 'Cannot locate Cairo library. Please check that it is installed on your system.'
]
]]]

!!! Sharing Libraries Between Bindings

To finish this chapter, let\'s define a new binding to another function in the same C library\: ==time==.
The ==time== function receives a (potentially null) C pointer and returns the current calendar time (as seconds of epoch), which we will once again assume is a ==uint== for simplicity.

We can define our new binding as follows, providing a ==NULL== pointer as the function argument.
(We leave it to the reader to look up the definition of the C function and determine the purpose of this argument.)

[[[language=smalltalk
FFITutorial class >> time [
	^ self ffiCall: #( uint time( NULL ) ) library: MyLibC
]
]]]

Our new binding references the ==MyLibC== library we defined earlier, so the above structure couples that code to both our bindings. To avoid such undesirable coupling, we can choose to refactor the class reference into a class method of our ==FFITutorial== class that can be used instead by all such bindings.

To continue our example,

[[[language=smalltalk
FFITutorial class >> myLibrary [
  ^ MyLibC
]

FFITutorial class >> ticksSinceStart [
	^ self ffiCall: #( uint clock() ) library: self myLibrary
]

FFITutorial class >> time [
	^ self ffiCall: #( uint time( NULL ) ) library: self myLibrary
]
]]]

This strategy, however, is still not as neat as we would like it to be. Further refactoring could clean this up, but fortunately for us, uFFI provides the support we need for sharing library definitions between bindings.

Any class defining a binding has the option of defining a default library by overriding the ==ffiLibrary== class method. Doing so allows us to omit a library definition altogether in our call\-out bindings as this default library will be automatically used by uFFI.

Let\'s see how this further simplies things for us\:

[[[language=smalltalk
FFITutorial class >> ffiLibrary [
  ^ MyLibC
]

FFITutorial class >> ticksSinceStart [
	^ self ffiCall: #( uint clock() )
]

FFITutorial class >> time [
	^ self ffiCall: #( uint time( NULL ) )
]
]]]

Of course, bindings defining a library explicitly will necessarily override this mechanism, so you still have the option of creating a class with bindings that mix both mechanisms in any manner you wish.

!!! Conclusion

In this chapter, we have seen the basics of writing our own uFFI call\-outs. We declare an FFI binding to a C function by specifying the name of the function, its return type, its arguments, and the library to which the function belongs. uFFI uses this information to load the library in memory, look up the function, demarshall our Pharo arguments to C types and push them, call the function, and marshall any C return values back into Pharo objects. Here is the final version of our call\out method:

[[[language=smalltalk
FFITutorial class >> time [
	^ self ffiCall: #( uint time( NULL ) )
]
]]]

As we can see, uFFI's ability to work with libraries as objects has protected our code from the distraction of platform implementation differences.

The next chapter covers function arguments of various types.  Although we glossed over its details on purpose, the ==time== binding described in the previous section has a literal ==NULL== pointer argument.
We will see how literal arguments, which may be of different flavors, are very convenient syntactic sugar for specifying default argument values.
They are not, however, the only means of conveying data from Pharo to the C world, as we ''can'' also send Pharo objects.
Of course, great care must be taken when sending objects into the C world, so we shall revisit marshalling in more detail next.
