## Marshalling, Types and Function ArgumentsIn the last chapter, we looked at the basics of FFI call-outs to define a Pharo uFFI binding to a C function.These first examples introduced the concepts of function lookup, library references, and marshalling of return values.However, the idea of marshalling is not specific to the transformation of return values from C to Pharo: it also involves the transformation of argument values from Pharo to C, and the sharing of values between the two environments.This chapter presents marshalling in more detail, focusing on function arguments.Our first examples show the capability of uFFI to use literals as default argument values.We then advance to other basic data types, from `String`s and `ByteArray`s all the way to C pointers and how to manipulate them within Pharo.This chapter finishes by presenting the different marshalling rules in uFFI for basic types, particularly how to manage platform-specific types.### A First Function ArgumentOur previous `clock()` example was one of the simplest uFFI bindings possible, as it does not require passing any arguments, and because we could easily tweak the binding to map the return value to an unsigned integer.To understand how to deal with functions that require arguments, let's consider the C `abs()` function, which receives an integer argument and returns its absolute value.As with `clock()`, `abs()` is another function in the standard C library, so we will continue using our `FFITutorial` class to create its binding.  Its prototype is declared as follows:```int abs( int n );```Creating a binding for such a function requires that we provide an `int` argument in our binding -- specifying both type and value.To ease the construction of argument bindings, uFFI will attempt to match any parameter names in our calling method to corresponding function parameters that have the same names.In other words, we can define our binding for `abs()` as a method with a single `n` keyword argument as follows \(remembering that our `FFITutorial` class now conveniently provides uFFI with the correct C library for us\):```language=smalltalkFFITutorial class >> abs: n [
	^ self ffiCall: #( int abs ( int n ) )
]```Creating this binding does not really add extra complexity to what we did in our previous examples.We create a simple method that uses the `ffiCall:` message, providing it an array argument enclosing a copy of the function's prototype, just as we did before.  \(And as with our earlier `FFITutorial` class methods, we're assuming the continued use of our `ffiLibrary` override to eliminate the need to add the `library:` keyword\).The part that's new here is the introduction of the `n` parameter and its C type, but no additional work is needed on our part to transform the Pharo object to a C value.  Also notice that uFFI knows to distinguish the argument's declared _type_ from its formal parameter _name_, while simultaneously matching up the name with our Pharo method's argument.We might even rename the parameter to use a more Pharo-_ish_ naming style, such as "`anInteger`":```language=smalltalkFFITutorial class >> abs: anInteger [
	^ self ffiCall: #( int abs ( int anInteger ) )
]```Finally, we can call this binding with a Pharo `SmallInteger` by entering the following in a playground:```language=smalltalkFFITutorial abs: -42.
=> 42```### MarshallingAs we saw regarding return values in Chapter 1, Pharo's uFFI also manages the transformation of function arguments for us. The syntax we used may give the impression that uFFI simply copies the Pharo integer value to the C stack; however, the marshalling rules that uFFI must follow are not that straight-forward.  Pharo and C use different internal representations for their data types, which must be modified in order to be exchanged, potentially in different ways \(usually depending on the host platform\).To illustrate how marshalling works, let's consider the case of transforming a Pharo `SmallInteger` to a C `int` type, as in our example.Internally, for efficiency purposes, Pharo represents `SmallInteger`s directly in binary, rather than as an object pointed to in the heap.  Therefore, to differentiate integers from object pointers, Pharo tags `SmallInteger` "pointers" with an extra bit to signify this special interpretation.Consider the `SmallInteger 2`; this value is represented in binary as the number `2r10`, but is internally represented in Pharo as `2r101`, where the _least_ significant bit \(LSB\) is shifted in as the added tag.  Since all Pharo object pointers are at least 32-bit aligned, we're guaranteed that their least significant bit will always be zero.  This makes a non-zero LSB a reliable indicator that we're dealing with a `SmallInteger` rather than a heap pointer.  \(This is also why Pharo `SmallInteger`s are "only" 31 bits in 32-bit images and 61 bits in 64-bit images\).This _representation mismatch_ requires that the uFFI transform `SmallInteger`s to C `int`s \(and vice-versa\) as follows \(using the values in our particular example\):- A Pharo `SmallInteger` value transformed to a C value needs to be logically shifted to the right, `2r101 >> 1`, transforming `2r101` to `2r10`.- A C integer value \(representable in 31/61 bits or less\) transformed to a Pharo `SmallInteger` needs to be shifted to the left and incremented, `(2r10 << 1) + 1`, transforming `2r10` to `2r101`.Each type-to-type transformation has its own particular rule that uFFI follows to ensure that the correct representation is always maintained.#### Pharo-to-C DemarshallingWhen demarshalling Pharo objects to C values, uFFI decides which transformation rule to use depending on two pieces of information.First, it considers the concrete type of the Pharo object, _its class_.Second, it considers the C type defined in the function binding as the target transformation type.At run time, when the binding method is executed, uFFI reads the type of the Pharo argument and transforms the argument object into the indicated C type representation \(if possible\), performing a type cast/coercion as necessary.These transformation rules can have consequences, which we illustrate with the following cases, using our previous `abs:` binding example:- `SmallInteger`s in 32-bit Pharo images are transformed to `int`s as expected \(since 31 bits cannot overflow into 32 bits\):```language=smalltalkFFITutorial abs: -42.
=> 42``````language=smalltalkFFITutorial abs: SmallInteger maxVal negated.
=> 1073741823```- `SmallInteger`s in 64-bit Pharo images _can_ overflow the size of a C `int` \(still 32 bits on most 64-bit hosts\), and so are coerced by truncating their value to fit, producing results similar to what a C program would produce in a similar situation.  Since the `maxVal` of a 64-bit Pharo `SmallInteger` is 60 '1' bits \(plus a sign bit\), it truncates to 32 '1' bits, which, to C, is the two's complement value -1.  Hence,```language=smalltalkFFITutorial abs: SmallInteger maxVal negated.
=> 1```- Pharo `LargeIntegers`, by contrast, are "infinite precision" \(no `maxVal`\), and do not have a corresponding C type to convert into.  Consequently, uFFI throws an error:```language=smalltalkFFITutorial abs: SmallInteger maxVal * -10.
=> Error: Could not coerce arguments```- Pharo floats, when provided as C `int` arguments, will be truncated \(mathematically\) to produce an integer:```language=smalltalkFFITutorial abs: Float pi.
=> 3```- But if the Pharo float is too large for a C integer, strange values can result due to coercion to 32 bits:```language=smalltalkFFITutorial abs: SmallInteger maxVal * Float pi.
=> -2147483648  "in 32-bit Pharo images"``````language=smalltalkFFITutorial abs: SmallInteger maxVal * Float pi.
=> 2007355392  "in 64-bit Pharo images"```- Pharo objects that are incompatible with the C `int` type are rejected, and an exception is thrown:```language=smalltalkFFITutorial abs: Object new.
=> Error: Could not coerce arguments```#### C-to-Pharo MarshallingA similar-yet-different story happens when marshalling C values to Pharo objects.In this case, uFFI decides the marshalling rule based on just the specified return type.At run time, when the binding method is executed and the C function returns, uFFI transforms the \(expected\) return value into the closest Pharo type corresponding to the declared C type.For example, a delared `int` return type will cause uFFI to interpret the returned value as either a `SmallInteger` or `Large(Positive|Negative)Integer`, depending on the size and sign of the data; a C`float` or `double` type will interpret the returned data as a Pharo `Float`.For example, our above evaluation of the following in a 32-bit Pharo image,```language=smalltalkFFITutorial abs: SmallInteger maxVal * Float pi.
=> -2147483648```returns a Pharo `LargeNegativeInteger`, since the binary return value, 2^31, will not fit in a Pharo `SmallInteger`.  It requires _32_ bits, so uFFI selects the object type it _will_ fit in, which is a `LargeNegativeInteger` object.#### Marshalling of Incorrectly Declared TypesThe marshalling rules we have seen above show that the way in which we specify function types is _crucial_ to the correct behavior of our bindings, and thus our applications.In other words, call-out bindings require that C types are correctly specified, otherwise run-time errors -- or even worse, viable but incorrect value transformations -- may happen.Let's consider as an example what happens if we create a companion `abs:` binding to operate on a `Float` argument instead of an integer, but which still uses the same C `abs()` function:```language=smalltalkFFITutorial class >> floatAbs: aFloat [
	^ self ffiCall: #( int abs ( float aFloat ) )
]```Now let's we evaluate this version in a playground using a negative `Float` value:```language=smalltalkFFITutorial floatAbs: -1.0.
=> 1082130432  "in 32-bit Pharo images"``````language=smalltalkFFITutorial floatAbs: -1.0.
=> 0  "in 64-bit Pharo images"```Although we expected the message to evaluate to `1` \(because the return value is still of type `int`\), this example returns `0` \(in 64-bit images\).To understand this result, we need to realize that our bindings, and the way we express their C types, are _independent_ of the actual function implementation we are calling.In other words, even if we 'set' the type of `abs()`'s argument to `float`, the `abs()` function in our system remains built and compiled to work only on C `int` values.  We're not _compiling_ the C functions in Pharo, only attaching and calling them.  So we must strictly and carefully adhere to their documented function declarations.What happens "under the hood" in this example is that uFFI transforms our `-1.0` Pharo float into a C `float`, then pushes it on the stack and calls the `abs()` function.  The function uses that value, but considers it to be an integer.And it happens that C integers and floats have the same bit size \(32 bits\), but vastly different representations in C.This produces either hilarious or _dangerous_ results...A similar problem arises if the return type of a function is incorrectly specified.Let's take for example a slightly modified version of our original `abs:` binding, this time declaring a C `float` return type:```language=smalltalkFFITutorial class >> floatReturnAbs: anInteger [
	^ self ffiCall: #( float abs ( int anInteger ) )
]```When this call returns, uFFI will interpret the returned value as a C float, and try to marshall it to a Pharo `Float`:```language=smalltalkFFITutorial floatReturnAbs: -3.
=> Float nan  "in 32-bit Pharo images"``````language=smalltalkFFITutorial floatReturnAbs: -3.
=> -1.07374176e8  "in 64-bit Pharo images"```Since the implementation of `abs()` actually returns an `int`, the bits are wrongly interpreted, producing not an error \(at least not in the 64-bit case\), but a strange value -- _one that your application might not detect_.  And if this kind of misinterpretation is only "slightly off", it can lead to buggy behavior that is maddeningly difficult to diagnose.So while writing library bindings with uFFI is fun and simple, the binding developer needs to make sure that the types are correctly declared, and that the correct version of the library is being used. Fortunately, for mature libraries, most of the time it is sufficient to simply "copy and paste the function declarations".### Function Argument BindingsWe have seen in the earlier introductory example how to use method parameters as arguments when writing function bindings.In this section, we explore other ways to define arguments -- in particular literal objects, instance variables, and class variables.#### Literal Object ArgumentsFrom time to time we will find ourselves calling C functions that require many more parameters than the ones we are actually interested in providing.For example, C functions may have extra parameters to select or control certain options and configurations, or they may have parameters that are only necessary in particular cases \(and which are ignored in others\).Although parameters such as these are deemed _optional_, we cannot leave them out of our binding definition -- they still need to be there for the C call to execute correctly. To make it easier to deal with such optional parameters, uFFI allows Pharo literal objects to be provided as function arguments.To see how this works, let's first imagine that for some reason we needed to call the `abs()` function with the `-42` argument exclusively.Using what we have learned up to this point, a simple way to define such a binding would be to define a normal Pharo method calling our binding with the hard-coded value `-42`:```language=smalltalkFFITutorial class >> absMinusFortyTwo [
	^ self abs: -42
]```This approach is convenient when we want both `abs:` and `absMinusFortyTwo` to be exposed to our user.It certainly benefits from the binding being declared only once, allowing us to isolate potential marshalling mistakes in a single location.However, we may not want to send the Pharo `abs:` message, as we're doing in this case.  Instead, we want to provide `-42` directly to the C `abs()` function, as a literal \(i.e. canned\) value.To provide for this, uFFI supports the use of literal arguments in C function bindings.  Rather than passing a method argument to the function binding, we can specify a literal value following its C type declaration:```language=smalltalkFFITutorial class >> absMinusFortyTwo [
	^ self ffiCall: #( int abs ( int -42 ) )
]```Notice that we don't just type in a Pharo integer for the expected argument and expect uFFI to perform implicit type conversion.  Even literal values such as integers must be preceded by a C type declaration \(`int` in the above example\).This type information is needed by uFFI to correctly determine how to transform the Pharo integer, given the many different forms in which it could be rendered.Consider that, in the case of C integers, a number can be signed or unsigned, and can occupy different sizes such as 8, 16, 32, or 64 bits.  Pharo can't guess; the C function expects a specific type to be provided, and the Pharo object containing the value doesn't reflect this.  We have to be explicit about the literal's 'type'.Most of the literals accepted in Pharo code are accepted in uFFI call-outs too: e.g., integers, floats, strings, arrays.We will present more detail about the different data types and how they are marshalled by uFFI in a subsequent section.#### Class VariablesIn the method above, we used a literal number as an argument in a uFFI call-out. Although handy, literal numbers fall into the category of so-called "magic numbers": Embedded literals in code that offer no explanation of where they came from, why they were chosen, or how they were calculated.  \(These are distinguished from _manifest constants_, which are more-or-less self-explanatory, such as using _pi_ in angle calculations or '2' when we need to divide a quantity in half.\)Embedding magic numbers in methods is a _code smell_ and should be avoided.  One way to handle these kinds of values is to parameterize them: assign them names, usually as a variable or named constant.  C libraries often define such constants using `#define` pre-processor statements such as:```language=c  #define MagicNumber -42```In Pharo, we can take a similar approach by defining such values in class variables.We only need to change the definition of our `FFITutorial` class to include a class variable such as `MagicNumber` \(which is therefore capitalized\), and then define a class-side `initialize` method to set its value \(_and explain why_\). Do **not** forget to execute this `initialize` method, otherwise the value won't get set!```language=smalltalkObject subclass: #FFITutorial
	...
	classVariableNames: 'MagicNumber'
  ...

FFITutorial class >> initialize [
	"Set this to -42 because.. Life, the Universe, and Everything."
	MagicNumber := -42.
]```Finally, we update our call-out binding to use our class variable, remembering that we still need to provide its type explicitly:```language=smalltalkFFITutorial class >> absMinusFortyTwo [
  ^ self ffiCall: #( int abs ( int MagicNumber) )
]```Just as with class variables, uFFI integrates transparently with variables defined in shared pools.Shared pools are useful for grouping common constants that need to be shared between different classes, bindings, or even libraries.The following code illustrates how we can modify our code to put our variable in a shared pool.Notice that the only code that changes is the class defining the variable.The binding using the variable remains unchanged.```language=smalltalkSharedPool subclass: #FFITutorialPool
	...
	classVariableNames: 'MagicNumber'
  ...

FFITutorialPool class >> initialize [
	"Set this to -42 because.. Life, the Universe, and Everything."
	MagicNumber := -42.
]

Object subclass: #FFITutorial
	...
	poolDictionaries: 'FFITutorialPool'
  ...

FFITutorial class >> absMinusFortyTwo [
  ^ self ffiCall: #( int abs ( int MagicNumber ) )
]```Using a shared pool does not change the normal Pharo usage of uFFI. If you want to learn more about Pharo shared pools, we recommend you take a look at _Pharo by Example 8.0_.#### Instance VariablesuFFI also supports using instance variables as arguments to a C call-out.When such a call-out is executed, the value of the instance variable is demarshalled to form the argument, using the type information in the binding definition.The use of instance variables in uFFI bindings can come in handy when defining object-oriented APIs to C libraries.Since objects hold values as well as define behaviors, they can both encapsulate the state required to perform the uFFI calls while masking the call-outs as normal messages.We see that the syntax is essentially the same as what we saw for class variables.  Note that we can can even hold the function name in a Pharo variable:```language=smalltalkMyClass >> doSomething [
	^ self ffiCall: #( int myFunctionNameInstVar ( int myArgumentInstVar ) ) library: LibC
]```We will let you, the reader, experiment with these as an exercise.#### Special Variables: The Case of `self`We can also pass `self` as an argument to a C call.Suppose we want to add the `abs()` function call to an extension of the class `SmallInteger`, in a method named  `absoluteValue`.  This would allow us to write expressions such as `-50 absoluteValue`.To do this, we simply add an `absoluteValue` method to `SmallInteger` and directly pass `self` as a \(typed\) argument.  Though a pseudo-variable, Pharo will demarshall `self` correctly as it does any instance variable:```language=smalltalkSmallInteger >> absoluteValue [
	^ self ffiCall: #( int abs ( int self ) ) library: LibC
]```Using `self` as an argument has many benefits beyond this simple example.In combination with complex types such as C `struct`s and opaque objects, using `self` as argument is a powerful tool for writing OOP-flavored bindings to C libraries.### Marshalling C PointersIn Pharo, the objects we send as method arguments are always conceptually "passed by reference".This means that every time we provide an object as an argument, the receiver and the sender hold references to the same object: the argument object is _shared_.\(One exception to this is the set of Pharo `SmallInteger`s, which are Pharo primitives, and therefore passed by value.  However, this implementation detail is completely transparent to Pharo code, and has no impact beyond the implementation of uFFI demarshalling rules, as we saw earlier\).In contrast to Pharo, many function arguments in C are, by default, "passed by value".For example, every time we send an integer or a float as an argument to a function, its value is _copied_ \(pushed onto the C stack\) prior to calling the function.Passing by value, while trivial for simple types such as numbers, usually demands more consideration when dealing with complex _mutable_ types, such as arrays and structures.  If an invoked function were to modify a _copy_ of data received as an argument, the original value held by the caller would remain unmodified -- which might not be the intended outcome.Therefore, in addition to _pass by value_, C also supports passing arguments by reference, in this case using **pointers** \(a C type that equates to an address in memory\).Use of a C pointer as an argument is often denoted explicitly in function declarations by prefixing the `*` character to a variable name \(although some C types are implicitly of pointer type\).For example, a function `foo()` that receives an `int` pointer as an argument and returns a `char` pointer will have a function declaration similar to the following:```language=cchar *foo ( int *arg );```uFFI supports pointers by introducing a new kind of object: `ExternalAddress`.`ExternalAddress`es are objects that represent memory addresses, thus their possible values range from `NULL` to the maximum possible address the host operating system allows, either 2^32 \(for 32-bit\) or 2^64 \(for 64-bit systems\), respectively.#### Obtaining an `ExternalAddress`The most common way of obtaining an `ExternalAddress` is to receive it as the return value of a called C function.A good example is the `libc` function `malloc()`, which takes an integer specifying the desired size of a heap buffer, tries to allocate a contiguous block of memory of the size requested, and, if successful, returns a pointer to the allocated region of memory.The C declaration of such function reads as follows \(from the `libc` manual\):```language=cvoid *malloc( size_t size );```To create a uFFI binding to it, we only need to copy-paste the declaration as follows:```language=smalltalkFFITutorial class >> malloc: aSize [
	^ self ffiCall: #( void * malloc ( size_t aSize ) ) library: LibC
]```Notice that this function returns a "generic pointer", of type `void *` \(meaning, what it points to in memory is _untyped_\). In uFFI, this is marshalled to an `ExternalAddress` object.In other words, our `malloc()` binding yields an `ExternalAddress` in return \(if successful\).For example, if we use the above binding to ask the system to allocate a buffer of 200 bytes for us, then on return we should have an address that points somewhere in the C heap:```language=smalltalkFFITutorial malloc: 200
 => (void*)@ 16r7FFBDE0DE030```But if we ask for more memory than there is currently available, `malloc()` will fail and return a `NULL` pointer instead:```language=smalltalkFFITutorial malloc: SmallInteger maxVal
 => (void*)@ 16r00000000```Consequently, we must always check the return value in cases like this, lest we invoke the infamous "null pointer assignment" bug.#### Pointers as ArgumentsPointers can appear as function arguments, too.Consider for example the function `free()`, used to de-allocate a block of memory previously allocated with, e.g., `malloc()`. As the complement to memory allocation functions, `free()` takes a memory pointer as an argument \(which is **required** to have originated from a memory allocation system call!\), de-allocates the memory pointed to by it, and returns nothing.The declaration of `free()` looks like this:```language=cvoid free( void *ptr );```As you might expect by now, uFFI supports pointer arguments by using C pointer syntax directly in function bindings.  And as expected, copy-pasting a C function declaration is usually enough to create bindings to such functions:```language=smalltalkFFITutorial class >> free: ptr [
	^ self ffiCall: #( void free( void *ptr ) ) library: LibC
]```Naturally, pointer arguments accept `ExternalAddress` objects. We have seen in the previous section that functions returning pointers provide us with such `ExternalAddress`es.So we are now able to allocate memory using a `malloc()` binding and give that memory back to the system using a `free()` binding, as shown in this example:```language=smalltalkanExternalAddress := FFITutorial malloc: 200.

FFITutorial free: anExternalAddress.```**Warning:** Always be careful when manipulating memory, especially when accessing it and freeing it.  For each `malloc()` that allocates memory, you must eventually call a corresponding `free()` to release it back to the system. Improper memory manipulation can lead to memory access errors and could cause your process to die \(or your system to crash\).#### Optional arguments, `NULL` pointers, and `nil`In general when using uFFI, we will not need to craft any pointers manually, other than `NULL` pointers.`NULL` pointers \(which are interchangeable\) can be easily created with the following expression:```language=smalltalkExternalAddress null
  => @ 16r00000000````NULL` pointers are useful because they are used in many libraries that have optional arguments.For example, in the family of memory allocation functions, the function `realloc()` takes two arguments: a pointer to a region of memory and a size.This function tries to enlarge the allocated region of memory to the requested size and returns the same pointer when successful.However, if a `NULL` pointer is provided as argument, `realloc()` operates instead like `malloc()` and just allocates a new region of memory.The declaration of `realloc()` looks like this:```language=cvoid *realloc( void *ptr, size_t size );```And the uFFI binding to this function might look like:```language=smalltalkFFITutorial class >> realloc: aPointer toSize: aSize [
	^ self ffiCall: #( void * realloc ( void* aPointer,  size_t aSize ) ) library: LibC
]```As noted above, we can use this binding for buffer allocation by providing a `NULL` `ExternalAddress` as its first argument:```language=smalltalkFFITutorial realloc: ExternalAddress null toSize: 200.
 => (void*)@ 16r7FFBDE0DE030```Finally, uFFI type marshalling allows us to use `nil` for arguments, too.  When a pointer is expected, `nil` will be demarshalled to a `NULL` pointer.Thus we could write our previous example in this way, too:```language=smalltalkFFITutorial realloc: nil toSize: 200.
 => (void*)@ 16r7FFBDE0DE030```### Type Marshalling Rules for Basic ObjectsIn Pharo, basic objects \(integer, floats, strings, booleans, characters\) are represented in memory differently than in C, thus each requiring special marshalling.Moreover, not all values in one language are seamlessly representable in the other.For example, while integers in Pharo can have arbitrary precision and will be enlarged on demand, integers in C _overflow_ and will simply be truncated.In this subsection, we go over all Pharo's basic types and explore all these rough corners of which a FFI developer should be aware.#### IntegersInteger types in C such as `short`, `int`, their long and unsigned versions, have fixed size.For example, `int`'s are 32 bits long on 32-bit machines and 64 bits long on 64-bit machines.This means that values that cannot be represented in that size will be truncated to fit.To illustrate this behaviour, consider the following two C functions: they initialize an integer value with the maximum possible value they can store, and then add one to it.```language=cvoid overflowing_int(){
  int input=INT_MAX;
  printf("Overflowing int: %d + 1 = %d\n", input, input + 1);
}

void overflowing_uint(){
  unsigned int input=UINT_MAX;
  printf("Overflowing unsigned int: %u + 1 = %u\n", input, input + 1);
}```Which yield for example:```Overflowing int: 2147483647 + 1 = -2147483648
Overflowing unsigned int: 4294967295 + 1 = 0```We observe that the results of executing such functions are \(when overflows are admitted/defined behaviour by the compiler\) mathematically incorrect.To explain it briefly, such behavior is due to the fact that C integers \(and other numeric types\) do not entirely follow mathematical semantics, but are instead tightly coupled to the semantics and limitations of the underlying machine and processor.We will refrain from further discussing the semantics of C, since they are outside the scope of this booklet, and may vary depending on the C standard and compiler used.On the other hand, integer values in Pharo have variable size.Indeed, Pharo integers' storage size is dynamically adjusted to fit the stored value.For example, the following piece of code shows how we can obtain the maximum `SmallInteger` value, and that adding one to it yields a `LargePositiveInteger`.The former class is used to represent integers up to a fixed size \(of 31 bits in 32-bit machines and 61 bits in 64-bit machines\), while the latter is used to represent integers that require more storage.```language=smalltalk(SmallInteger maxVal + 1) class
 => LargePositiveInteger```While uFFI value marshalling takes care of most conversions \(e.g., representation differences, two-complements...\), the uFFI user still has to be careful when exchanging integers between Pharo and a C library. This mostly boils down to:- the integer return type and the integer types of the arguments defined in the uFFI callout should correspond to the actual types in the library. E.g., mistaking a `long` by an `int`, or wrongly defining a signed int as not signed will make uFFI interpret such values wrongly.- Pharo integer values used as arguments should fit in the target argument type. Otherwise such value will be truncated.#### Floating Point NumbersFloating point numeric types in C such as `float` and `double` are also restricted by the limitations of the underlying hardware.Since hardware is not infinite, floating point numbers cannot be represented with infinite precision.The C type `float` is a precision floating point number, while `double` is a double precision floating point number.The following example C code illustrates how precision is lost: it first stores a floating point number in variables of type `float` and `double`, it then prints it using the `printf` function and requiring a precision of 18 digits after the decimal dot.```language=cvoid printFloatingPointNumbers(){
  //Both floating point numbers should have the same value
  float x = 3.141592653589793238;
  double y = 3.141592653589793238;
  
  printf("Float is: %20.18f\n", x);
  printf("Double is: %20.18f\n", y);
}```The example above prints the following to standard output.Although we asked for a precision of 18 digits, and 18 digits were printed to the stdout, not all of those 18 digits correspond to the original digits specified in our code.Moreover, we see that using a single precision type loses more precision than does double precision.```Float is: 3.141592741012573242
Double is: 3.141592653589793116```Pharo floating point numbers are double precision floating point numbers as explained above.uFFI marshalling will then take care of the following conversions:- If a Pharo float is sent as a `double` argument, the Pharo double precision floating point number will be copied as is.- If a Pharo float is sent as a `float` argument, Pharo float will be previously converted to a single precision float before.- C floats returned by functions will be transformed to double precision Pharo floats. If the function return type is `float` it will then add **noisy** digits to complete its decimal representation.#### CharactersCharacters in C are represented using the `char` type which is, although unintuive, a numeric type and not a textual type.This means that a `char` value does not actually represent a character, but some bytes encoding a character.And the actual character value of those bytes depend on how those bytes are actually interpreted.The reason for this is that the C programming language predates the nowadays broadly-used text encoding standards such as Unicode and its encoding formats such as utf-8 and utf-32.Historically, the `char` type stored 1 byte values, and was used to store ascii character values.However, the ascii encoding is not sufficient to represent many languages which have more characters than can possibly fit in a single byte.On the other hand, Pharo represents characters with their unicode code point, i.e., a unique identifier assigned to each character by the unicode standard.Unicode codepoints are integer numbers that may not fit the typical single byte of the C `char` type.The uFFI marshalling rules for characters is as follows:- A Pharo character sent as argument has its code point truncated and copied to the function argument.- A `char` return value is interpreted as a codepoint, and a Pharo Character with such codepoint is returned.However, care is needed with these conversions because the `char` type is actually a numeric type, and it mismatches with the unicode codepoints within Pharo.This turns the manipulation of character values into a potential source of bugs.We recommend that FFI developers carefully study how `char` types are used in each target library.Some C libraries interpret `char` values as ascii values, but unicode code points only match ascii values up to 127.For example, while in ascii the euro character \(€\) is represented with the 0x80 value, its unicode code point is 0x20AC.Other libraries use `char` values to represent raw bytes, which will be processed later by an encoding such as utf-8.#### BooleansSince the C99 standard, C includes support for booleans with the `bool` type, and its `true` and `false` values are defined in the `stdbool.h` header.Pharo booleans are transformed to C booleans seamlessly when using the `bool` type in the FFI callout signature.```language=cvoid printBoolean(bool b){
	printf("Boolean: %d\n", b);
}``````language=smalltalkFFITutorial class >> printBoolean: b [
	^ self ffiCall: #( void printBoolean ( bool b ) )
]```### More Predefined Data TypesuFFI includes a set of predefined data types that are accessible to all FFI libraries and call-outs.These data types represent all the data types defined in the C standard, as well as some useful aliases. We will categorize the data types as: fixed-size types, aliases and ABI dependent types. The fixed-size have the same size in all the platforms, while the ABI dependent types may change their size depending on the running platform.Also, uFFI includes a set of useful aliases to ease the creation of FFI callouts by allowing a wider range of function signatures to simply be copy/pasted.#### Fixed Size TypesuFFI includes a set of fixed size integer types. These types are platform independent.They come in two flavours: signed and unsigned.| Type | Byte Size | Signed |  || --- | --- | --- | --- || int8 | 1 | Yes |  || int16 | 2 | Yes |  || int32 | 4 | Yes |  || int64 | 8 | Yes |  || Type | Byte Size | Signed |  || --- | --- | --- | --- || uint8 | 1 | No |  || uint16 | 2 | No |  || uint32 | 4 | No |  || uint64 | 8 | No |  |#### Floating-point TypesuFFI also provides data types for handling IEEE-754floating point data types. The following table presents the data-types usable in FFI bindings.| Type | IEEE 754 | Mantissa | Exponent | Common Name |  || --- | --- | --- | --- | --- | --- || float16 | binary16 | 11 bits | 5 bits | Half Precision |  || float32 | binary32 | 24 bits | 8 bits | Single Precision |  || float64 | binary64 | 53 bits | 11 bits | Double Precision |  || float128 | binary128 | 113 bits | 15 bits | Quadruple precision |  |All of these types will be correctly translated to a `Float` instance in Pharo, which has a precision equivalent to `float64`.#### Platform Dependent TypesuFFI is designed to allow developers to write code that is portable across different platforms.As there are types with platform-dependent sizes, uFFI implements the following platform dependant types.These types are automatically handled correctly depending on the running platform.| Type | 32 bits size | Windows \(64 bits\) | Linux \(64 bits\) | OS X \(64 bits\) |  || size\_t | 4 | 8 | 8 | 8 |  || long | 4 | 4 | 8 | 8 |  || ulong | 4 | 4 | 8 | 8 |  |#### AliasesOne of the nicest features of uFFI is the ability to implement the FFI callouts by copy/pasting the definitions of C Functions. To have more extensive support for copy/pasting definitions, uFFI includes a series of aliasesmapping commonly used data types to uFFI types.The following table presents the integer aliases: | Alias | Target Type |  || --- | --- | --- || unsignedByte | uint8 |  || unsignedChar | uint8 |  || uchar | uint8 |  || byte | uint8 |  || sbyte | int8 |  || schar | int8 |  || signedByte | int8 |  || signedChar | int8 |  || unsignedShort | uint16 |  || ushort | uint16 |  || short | int16 |  || signedShort | int16 |  || uint | uint32 |  || int | int32 |  || signedLong | int32 |  || unsignedLong | uint32 |  || longlong | int64 |  || ulonglong | uint64 |  |Also there are aliases for floating point types:| Alias | Target Type |  || --- | --- | --- || shortFloat | float16 |  || float | float32 |  || double | float64 |  |### ConclusionIn this chapter we have studied the basics of uFFI call-out arguments and their marshalling.The arguments of a function can be the arguments of the method they are declared in, instance variables, class variables, self, or Pharo literal objects.Arguments should declare a type, so uFFI knows how to transform that object into a C equivalent.Failing to correctly declare the type can lead to misbehaviours in an application due to incorrect transformation.Basic types covered by uFFI include integer values, floating point values, booleans, characters and pointers.Pointers are handled using the special uFFI class `ExternalAddress`, and its special value _NULL_ can be acquired with the `null` class side message.Finally, other basic types have special marshalling rules for transforming Pharo values into C values, which need to be considered carefully.In particular, we have seen that integers can suffer truncations and overflows in C, floating point numbers may suffer from loss of precision, and characters in Pharo are interpreted as unicode code points while each C library can interpret characters as they please.The next chapter explores other data types that can be built from these basic data types: arrays, structures, enumerations and opaque objects.